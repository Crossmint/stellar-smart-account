#![no_std]
use soroban_sdk::{
    contract, contractimpl, contracttype, symbol_short, vec, Address, Bytes, BytesN, Env, Symbol,
    Val, Vec,
};
use stellar_access_control::{grant_role_no_auth, set_admin, AccessControl};
use stellar_access_control_macros::only_role;
use stellar_default_impl_macro::default_impl;

#[contracterror]
pub enum WebAuthError {
    MissingArgument = 1,
}

#[contractimpl]
impl WebAuthContract {
    pub fn __constructor(env: Env, admin: Address) -> () {
        env.storage().instance().set(&DataKey::Admin, &admin);
    }

    /// Verifies the client is authorized to authenticate with the server
    ///
    /// Arguments:
    /// - account: The client account address
    /// - home_domain: The home domain
    /// - web_auth_domain: The server's domain
    /// - web_auth_domain_account: The server's SIGNING_KEY
    /// - client_domain: The client domain (optional)
    /// - client_domain_account: The client domain's SIGNING_KEY (optional)
    /// - nonce: A random string generated by the server to prevent replay attacks
    pub fn web_auth_verify(env: Env, args: Map<Symbol, String>) -> Result<(), WebAuthError> {
        if let Some(address) = args.get(Symbol::new(&env, "account")) {
            let addr = Address::from_string(&address);
            addr.require_auth();
        } else {
            return Err(WebAuthError::MissingArgument);
        }

        if let Some(web_auth_domain_account) =
            args.get(Symbol::new(&env, "web_auth_domain_account"))
        {
            let addr = Address::from_string(&web_auth_domain_account);
            addr.require_auth();
        } else {
            return Err(WebAuthError::MissingArgument);
        }

        // Optional client domain verification
        if let Some(client_domain_account) = args.get(Symbol::new(&env, "client_domain_account")) {
            let addr = Address::from_string(&client_domain_account);
            addr.require_auth();
        }

        Ok(())
    }
}
